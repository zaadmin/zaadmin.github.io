## 继承

    A对象通过继承B对象，就能直接拥有B对象的所有属性和方法

### 继承的六种方式


*  原型链继承

    该方法实现的本质是通过将子类的原型指向了父类的实例，所以**子类的实例就可以通过_proto_访问到Child.prototype也就是Parent的实例，这样就可以访问到父类的私有方法，然后再通过_proto_指向父类的prototype就可以获取到父类原型的方法**
    
    子类继承父类的属性和方法是将父类的私有属性和共有方法都作为自己的公有属性和方法

    在子类中添加新的方法或是重写父类方法时，切记要放在替换原型之后

    ### 特点： 

        * 父类新增原型方法/原型属性，子类都能访问
        * 简单，易于实现
    
    ### 缺点：

        *  无法实现多继承
        *  来自原型对象的所有属性被所有实例共享
        *  创建子类实例时，无法向父类构造函数传参
        *  要想为子类新增属性和方法，必须要在Child.prototype = new Parent()之后执   行，能放到构造器中 

*  借用构造函数继承

    在子类型构造函数中通过call()调用父类构造函数

    ### 特点： 
    
        * 解决了原型链继承中，子类实例共享父类引用属性的问题
        * 创建子类实例时，可以向父类传递参数
        * 可以实现多继承（call多个父类对象）

    ### 缺点：

        * 实例并不是父类的实例，只是子类的实例
        * 只能继承父类的实例属性和方法，不能继承父类原型属性和方法
        * 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能

* 原型链+借用构造函数的组合继承

    通过调用父类构造 ，继承父类的属性并保留传参的特点，然后通过将父类实例作为子类原型，实现函数复用

    ### 特点：

        * 可以继承实例的属性/方法，也可以继承原型属性/方法
        * 不存在引用属性共享问题
        * 可传参
        * 函数可复用

    ### 缺点
     
        * 调用了两次父类构造函数，生成了两份实例

* 组合继承优化1

    通过父类原型和子类原型指向同一对象，子类可以继承到父类的公有方法当做自己的公有方法，而且不会初始化两次实例方法/属性，避免了组合继承的缺点

    ### 优点: 

        * 不会初始化两次实例方法/属性,避免了组合继承的特点

    ### 缺点： 

        * 没办法辨别实例是子类还是父类创造的，子类和父类的构造函数指向同一个

* 组合继承优化2

    借助原型可以基于已有的对象来创建对象，let b = Object.create(a)以a对象为原型，生成了b对象。b对象继承了a 的所有属性和方法。

    > 子类继承了所有父类原型对象的属性和方法。 目前来说，最完美的继承方法

* ES6中的class 继承

    继承机制： 
        先将父类实例对象的属性和方法，加到this上面（必须先调用super方法）,然后再用子类的构造函数修改this

    > class关键字只是原型的语法糖，Javascript继承仍然是基于原型实现的

    ### 优点： 

        * 语法简单易懂，操作更方便

    ### 缺点： 

        * 并不是所有的浏览器都支持class关键字

链接： https://segmentfault.com/a/1190000016708006
    

    
